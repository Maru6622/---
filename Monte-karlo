import jetbrains.letsPlot.export.ggsave
import jetbrains.letsPlot.geom.geomPoint
import jetbrains.letsPlot.letsPlot
import kotlin.collections.ArrayList
import kotlin.math.PI
import kotlin.random.Random
import kotlin.math.*
fun V (n: Int, R: Double, N:Int): Double {
    val m=N
    var g=0.0
    val b=(2*R).pow(n)//объём n-мерного куба, в который вписан n-мерный шар
    var k:Double
    var z:Double
    val gen= Random(100000)
    val res: ArrayList<Double> = ArrayList(n)
    for(i in 0 until n)
    {
        res.add(gen.nextDouble(1.0))
    }
    for(j in 1 until m){
        k=0.0
        for(i in 0 until n){
            z=gen.nextDouble(-R,R)
            res[i]=z
        }
        for (c in 0 until n){
            k=k+(res[c].pow(2))
        }
        if (k<=R.pow(2)){
            g=g+1.0
        }
    }
    return (b*g)/m
}
fun sigma(o:Double): Double {
    var s=0.0
    for (i in 0 until 1000){
        s=s+(o-PI).pow(2)
    }
    s=(s/1000).pow(0.5)
    return s
}
fun main(){
    val D=10
    val V: ArrayList<Double> = ArrayList(D)
    val n: ArrayList<Int> = ArrayList(D)
    for(i in 0 until D){
        V.add(V(i+1,1.0, 100000))
        n.add(i+1)
    }
    val data = mapOf<String, Any>("V" to V, "D" to n)
    val fig = letsPlot(data) + geomPoint(
        color = "dark-blue",
        size = 1.0
    ) { x = "D"; y = "V" }
    ggsave(fig, "V(D).png")
    val S: ArrayList<Double> = ArrayList(D)
    val N: ArrayList<Int> = ArrayList(D)
    for(i in 100 .. 10000){
        S.add(sigma(V(2, 1.0, i)))
        N.add(i)
    }
    val data1 = mapOf<String, Any>("S" to S, "N" to N)
    val fig1 = letsPlot(data1) + geomPoint(
        color = "dark-blue",
        size = 1.0
    ) { x = "N"; y = "S" }
    ggsave(fig1, "Sigma.png")
}
